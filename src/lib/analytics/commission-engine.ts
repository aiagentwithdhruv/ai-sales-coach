/**
 * Commission Calculation Engine
 *
 * Calculates commissions for the AI sales team based on deal outcomes.
 * Useful for:
 *   - Showing the "cost" of each AI agent (like paying a real employee)
 *   - ROI calculation: cost vs revenue generated
 *   - Understanding which agents deliver highest returns
 *
 * Commission Model:
 *   Agent "commissions" = platform cost attributed to each agent's contribution.
 *   This isn't real money paid out — it's a visualization of how the
 *   subscription cost maps to value generated by each agent.
 */

import { createClient } from "@supabase/supabase-js";
import { getAgentPerformance, type AgentType } from "./deal-attribution";
import { TIERS, type TierSlug } from "@/lib/pricing";

const getAdmin = () =>
  createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

// ─── Types ─────────────────────────────────────────────────────────────────

export interface CommissionReport {
  period: { start: string; end: string };
  subscription: {
    tier: TierSlug;
    monthlyCost: number;
    agentCount: number;
  };
  agents: AgentCommission[];
  totals: {
    totalCost: number;
    totalRevenue: number;
    netROI: number;
    roiMultiple: number; // revenue / cost
  };
}

export interface AgentCommission {
  agent_type: AgentType;
  agent_label: string;
  allocated_cost: number; // portion of subscription cost
  revenue_generated: number;
  deals_contributed: number;
  deals_won: number;
  roi_multiple: number;
  cost_per_deal: number;
  cost_per_lead: number;
  efficiency_score: number; // 0-100
}

export interface ROIMetrics {
  cost_per_lead: number;
  cost_per_qualified: number;
  cost_per_meeting: number;
  cost_per_deal_won: number;
  avg_deal_size: number;
  ltv_to_cac_ratio: number;
  payback_period_days: number;
  monthly_roi_percent: number;
}

// ─── Commission Calculation ────────────────────────────────────────────────

/**
 * Generate a commission report for a given period.
 */
export async function generateCommissionReport(
  userId: string,
  period: { start: string; end: string }
): Promise<CommissionReport> {
  const supabase = getAdmin();

  // Get user's subscription tier
  const { data: sub } = await supabase
    .from("user_subscriptions")
    .select("plan_type")
    .eq("user_id", userId)
    .eq("status", "active")
    .maybeSingle();

  const tier = (sub?.plan_type || "starter") as TierSlug;
  const tierConfig = TIERS[tier] || TIERS.starter;
  const monthlyCost = tierConfig.monthlyPrice;
  const agentCount = tierConfig.agentCount;

  // Get agent performance data
  const performance = await getAgentPerformance(userId, period);

  // Calculate months in period for cost pro-rating
  const startDate = new Date(period.start);
  const endDate = new Date(period.end);
  const monthsInPeriod = Math.max(
    1,
    (endDate.getFullYear() - startDate.getFullYear()) * 12 +
      (endDate.getMonth() - startDate.getMonth()) + 1
  );
  const totalCost = monthlyCost * monthsInPeriod;

  // Allocate cost to agents proportionally by activity
  const totalTouches = performance.totals.total_touches || 1;

  const agents: AgentCommission[] = performance.agents.map((agent) => {
    const touchShare = agent.total_touches / totalTouches;
    const allocatedCost = Math.round(totalCost * touchShare * 100) / 100;
    const costPerDeal =
      agent.deals_touched > 0
        ? Math.round((allocatedCost / agent.deals_touched) * 100) / 100
        : 0;
    const costPerLead =
      agent.total_touches > 0
        ? Math.round((allocatedCost / agent.total_touches) * 100) / 100
        : 0;
    const roiMultiple =
      allocatedCost > 0
        ? Math.round((agent.revenue_attributed / allocatedCost) * 100) / 100
        : 0;

    // Efficiency score: combo of ROI + win rate + activity
    const winRate = agent.deals_touched > 0 ? agent.deals_won / agent.deals_touched : 0;
    const efficiency = Math.min(
      100,
      Math.round(
        roiMultiple * 10 + // ROI weight
          winRate * 50 + // Win rate weight
          Math.min(agent.total_touches, 50) // Activity cap
      )
    );

    return {
      agent_type: agent.agent_type,
      agent_label: agent.agent_label,
      allocated_cost: allocatedCost,
      revenue_generated: agent.revenue_attributed,
      deals_contributed: agent.deals_touched,
      deals_won: agent.deals_won,
      roi_multiple: roiMultiple,
      cost_per_deal: costPerDeal,
      cost_per_lead: costPerLead,
      efficiency_score: efficiency,
    };
  });

  const totalRevenue = performance.totals.total_revenue;
  const netROI = totalRevenue - totalCost;
  const roiMultiple = totalCost > 0 ? Math.round((totalRevenue / totalCost) * 100) / 100 : 0;

  return {
    period,
    subscription: { tier, monthlyCost, agentCount },
    agents,
    totals: { totalCost, totalRevenue, netROI, roiMultiple },
  };
}

/**
 * Calculate overall ROI metrics for a user.
 */
export async function calculateROIMetrics(
  userId: string,
  period: { start: string; end: string }
): Promise<ROIMetrics> {
  const supabase = getAdmin();

  // Get subscription cost
  const { data: sub } = await supabase
    .from("user_subscriptions")
    .select("plan_type")
    .eq("user_id", userId)
    .eq("status", "active")
    .maybeSingle();

  const tier = (sub?.plan_type || "starter") as TierSlug;
  const monthlyCost = TIERS[tier]?.monthlyPrice || 297;

  // Get deal stats
  const { data: contacts } = await supabase
    .from("contacts")
    .select("deal_stage, deal_value, created_at")
    .eq("user_id", userId)
    .gte("created_at", period.start)
    .lte("created_at", period.end);

  const allLeads = contacts?.length || 0;
  const qualified = contacts?.filter((c) =>
    ["qualified", "proposal", "negotiation", "won"].includes(c.deal_stage)
  ).length || 0;
  const won = contacts?.filter((c) => c.deal_stage === "won") || [];
  const wonCount = won.length;
  const totalRevenue = won.reduce((s, c) => s + (c.deal_value || 0), 0);

  // Calculate months in period
  const startDate = new Date(period.start);
  const endDate = new Date(period.end);
  const months = Math.max(
    1,
    (endDate.getFullYear() - startDate.getFullYear()) * 12 +
      (endDate.getMonth() - startDate.getMonth()) + 1
  );
  const totalCost = monthlyCost * months;

  // Get meeting count from call logs
  const { count: meetingCount } = await supabase
    .from("call_logs")
    .select("*", { count: "exact", head: true })
    .eq("user_id", userId)
    .eq("outcome", "meeting_booked")
    .gte("created_at", period.start)
    .lte("created_at", period.end);

  const meetings = meetingCount || 0;

  const avgDealSize = wonCount > 0 ? Math.round(totalRevenue / wonCount) : 0;
  const costPerLead = allLeads > 0 ? Math.round((totalCost / allLeads) * 100) / 100 : 0;
  const costPerQualified = qualified > 0 ? Math.round((totalCost / qualified) * 100) / 100 : 0;
  const costPerMeeting = meetings > 0 ? Math.round((totalCost / meetings) * 100) / 100 : 0;
  const costPerDealWon = wonCount > 0 ? Math.round((totalCost / wonCount) * 100) / 100 : 0;

  // LTV:CAC — assume avg 12-month customer
  const avgLTV = avgDealSize * 12;
  const ltvToCac = costPerDealWon > 0 ? Math.round((avgLTV / costPerDealWon) * 10) / 10 : 0;

  // Payback period
  const monthlyRevenue = months > 0 ? totalRevenue / months : 0;
  const paybackDays = monthlyRevenue > 0
    ? Math.round((monthlyCost / monthlyRevenue) * 30)
    : 0;

  // Monthly ROI %
  const monthlyROI = monthlyCost > 0
    ? Math.round(((monthlyRevenue - monthlyCost) / monthlyCost) * 100)
    : 0;

  return {
    cost_per_lead: costPerLead,
    cost_per_qualified: costPerQualified,
    cost_per_meeting: costPerMeeting,
    cost_per_deal_won: costPerDealWon,
    avg_deal_size: avgDealSize,
    ltv_to_cac_ratio: ltvToCac,
    payback_period_days: paybackDays,
    monthly_roi_percent: monthlyROI,
  };
}
